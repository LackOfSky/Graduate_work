///
notes
./gradlew wrapper --gradle-version=8.7 - если возникает ошибка версии gradle на другом компьютере


//

TODO
UserInfo
    - привязать инфо к уникальному id (устройства)
    - реализовать прием UserInfo
    // альтернатива: отправлять вместе с данными о пользователе

NettyServer
    - сделать обработку ошибок закрытия соединения с клиентом
    - сделать логику работы security handler
                handshake и тд

NettyServerHandler
    - добавить логику подтверждения добавления пользователя (approve\drop)


SEND_MESSAGE
    - корректно сформировать json, с указанием его типа и сопутствующих полей

TODO: ClientPartP2P - установить обработчик, который будет рассылать пирам данные о пользователе, если они изменились


TODO: FEATURE
    В PeerDiscovery оставлен баг для отладки
    //if(SERIVCE_NAME != event.name) {
    }
TODO: баг сравнения user в серверной части (discovery или server). ибо изначально переопределялся equals и hashcode (возможно этой ошибки и не допустил)

идея discovery - добавить возможность обновлять найденые сервисы, и кнопки включения-отключения discovery

идея для хранения клиентских подключений:
    Map<SocketAddress, Channel>:
        нашли пира, на onClick к нему создаем клиентский канал. Добавляем в мап значение канала и ключ User \
        далее для отправки сообщения к нему будет использоватся метод: sendTo(user: User, message: String) //p.s. message: String - рассмотрим возможность отправки другого типа данных. возможно ByteArray

 п2п клиент. клас, который должен хранить все подключения, обращаться месседжами к подключению через переданого ему юзера, и следить за добавлением, изъятием пользователей


 .................................
 прописать функциональность сервера
 /***
    Сервер: * підіймає discovery, виявляє інші сервіси     (можливо скоротити до пошуку безпосередньо наших активних сервісів netty)
            * підіймає сервер, що приймає вхідні данні
            * контролює втрату зв'язку з клієнтами та відображає це клієнтській частині п2п
            * відправляє клієнтський запит з вказанням данних користувача "серверу"
            * створює "нотифікації"
 */
 ..................................
 прописать функциональность клиента
 /***
    Клієнт: * зберігає активних користувачів-друзів         MutableStateFlow<MutableMap<User, NettyClient>>(mutableMapOf())
            * зберігая активних користувачів-сторонніх      MutableStateFlow<MutableSet<User>>(mutableSetOf())
            * надає методи серверній частині для підняття\вимкнення клієнтської сторони
            * надає viewModel метод send для відправки повідомлень
 */





 v0.05
(DONE) Goals:
(DONE)    - проверить работоспособность подключения через wifi-direct на физических устройствах.
(DONE)    - сделать интерфейс сообщений
(DONE)    - friendsScreen tab3 - сделать "waiting for consent to connect" (отдельный список. когда он пуст - сделать вкладку - disable)
(DONE)    - UPD: Третюю вкладку оставить для апрувов, а отображение запрошеных оставить в листе пиров: (добавить кнопки "cancel" + disabled "approve")
(DONE)    - friends screen - реализовать отправку запроса в друзья пользователям
(DONE)    - сделать статусы запросов: request: request-approve, request-cancel, request-reject, request-delete.
(DONE)    - проверить логику добавления и удаления пользователей из базы данных
(DONE)    - перебрать логику реквест-респонса
(DONE)    - создать в client part 2 списка: approving users and requested users
(DONE)    - подумать что сделать с полем id класа User. нас не устраивает, в каждой базе данных своя уникальная номерация, которая передается в нашу базу данных
(DONE)    - баг User: реализовать взаимосвязть User по уникальному id, но если переделать hashcode и еquals - будут проблемы обновления ui
                        (был создан UserDTO, который вместо user взаимодействует с ui)
(DONE)    - Friend item: реализовать навигацию в сообщения
(DONE)    - сделать интерфейс списка чатов
(DONE)    - пересмотреть навигацию по приложению
(REJECTED)- переделать реализацию базы данных: chat participent с id владельца базы данных, chatId и participent
                (была переделана реализация БД)
(DONE)    - сделать логику добавления и удаления пользователя и чата одновременно
            (решено посредством установки имени чата равное уникальному id пользователя, с которым ведётся чат)
(DONE)    - сделать чат айтем - "заметки", реализовать возможность написания туда сообщений
                (частично реализовано путём преобразования личного чата)
(DONE)    - send message model: пользователь отправляет сообщение, ждёт подтверждения приема сообщения с его датой получения, и id в базе данных
                        описание:
(REJECTED)                         *краткий кейс: пользователь отправил сообщение, и ждёт колбек для добавления сообщения в бд.
(NEXT)                              * если сообщение не будет доставлено  - будет ошибка. тут в силу вступают статусы сообщения.
(DONE)                              Альтернатива: сделать ID сообщения типом строка, и подписывать как пользователь + числовое значение id
(DONE)    - реализовать CRUD-операции для сообщений + возможность копировать текст
(DONE)    - //toast включите wifi + геолокацию wifi direct manager

(DONE) feachure: ошибка перезаписи нашего пользователя, если мы обнаруживаем пользователя с id= 1 // сейчас обращения ведутся по униклаьным айди пользователя, вместо порядковых в бд
            удаление сообщений будет производится лишь на своем устройстве. Пока как-то так //Решается путём выполнения операций, когда статус собеседника - онлайн


------------------------------------------------------------------------------------------------------------

 v0.06
 Goals:
          - реализовать "ожидающие сообщения" (для будущих  версий)
          - реализовать отображение "неудачно отправленых сообщений", с кнопкой "переслать обратно" (для будущих  версий)
          - забегаю на перед: статус проверки: сообщение можно будет успешно принять, только если id отправителя совпадает с айди чат-мембера в чате

          - для личных чатов сделать кнопку "удалить везде", которая будет enabled, когда собеседник онлайн
          - до CRUD-операций с сообщениями добавить кнопку "изменить, которая будет активна когда собеседник онлайн"
          - message item: реализовать кнопки: reply, redirect
(DONE)    - баг сообщений. сообщения то добавляются, то перезаписываются
          - реализовать возможность добавления медиа в чат (передачу картинок, видео, и тд. архивы и прочее файлы, скорее всего, отдельно)

(DONE)    - реализовать логику добавления\измеения иконки пользователя (с служебным класом для ее CRUD-операций)
(DONE)    - реализовать логику добавления\измеения баннера пользователя
                        (загвоздка в способе хранения изображения: оптимальнее для нас (но не для базы данных ) хранить в бд, ограничивая объем файла
                         правильнее - хранить в кеше приложения и в userInfo передавать uri. Как вариант - сделать userInfoDTО, который будет передавать файл картинки
                         Подзадачи:
          - пользователю будет отправлятся userInfoDTO, на базе userInfo.
(READ)                      - userInfo станет внутренним для нашего приложения, для хранения дичных данных.
                  (DONE)    - обращаемся в хранилище. запихиваем картинку в хранилище. оставляем ссылку в базе данных userInfo.banner
                            - когда значение меняется - преобразовуем userInfo в userInfoDTO и отправляем пользователю.
(DONE)    - добавить отображение онлайн-статуса пользователя
                Подзадачи:
          (DONE)    - когда сервис работает - статус онлайн. переменная или stateFlow в сервисе, или бродкаст
          (DONE)    - кнопку в меню для включения-отключения сервиса
          (REJECTED)- разделить логику discovery и работу кластеров
(DONE?)   - исправить баг запуска сервиса с ошибкой создания группы  p.s. (отпала путём оборачивания createGroup в корутину)


 todo         - сделать DTO для пересылаемых типов данных
          - сделать дефолтную иконку

 Main:
          - peerListListener в wifi direct manager. отследить работоспособность
          - проверить присвоение id для обнаруженых устройств. Не присваивать id автоматически. присваивать в порядке добавления, когда мы его уже добавляем в друзья

 Main 0.06:
(DONE)    - Сервер:
                (DONE) - Создаем группу                (Клас DirectGroupManager)
                (DONE) - Поднимаем локальный сервис
                                (Включением-выключением локального сервиса Можем управлять видимостью для посторонних устройств)
                (DONE) - Публикуем NSD (непосредственно для подключения через сеть. так же можно будет использовать через wifi в рамках одной локальной сети)
                (DONE) - создаем клас, который будет отвечать за эти действия (WiFiDirectService)
                (DONE) - ошибка удаления подключеного пользователя, при разрыве подключения
                                (выявлена при тестировании на том же устройстве.
                                может сопуствтоватся ошибкой добавления пользователя)
                (DONE) - отследить где удаляется активный пользователь.
                (DONE)          (после запроса whoami, сервер разрывает соединение и подключается как клиент)
                (DONE)              соответственно, после разрыва клиентского соединения, нужно изымать активного пользователя
                (DONE)             - вынести логику добавления -удаления активного пользвателя в клиентскую часть addActiveUser
                (DONE)  - убрать проверку на ту же машину, и проверять какой пользователь подключился. если наш - то отключатся от сервиса

Feature:


(после тестирования работоспособности р2р)    - chat dialog viewModel реализовать логику проверки онлайн-статуса учасников чата (актуально для груповых чатов)


------------------------------------------------------------------------------------------------------------
 v0.10
 Реализовано подключение и обнаружение в рамках сети

 todo:

(DONE)    - фикс добавления в друзья
(CANCELED)    - прописать отправку user info
    - добавить отправку реквеста на получение user info, если данные отсутствуют
(CHECK IT)    - фикс проблем с обновлением интерфейса
    - добавить систему уведомлений (на будущее)
    - фикс обнаружения + подключения через wifi direct
    - переписать уровень репозитория с LiveData на Flow


------------------------------------------------------------------------------------------------------------
 v0.12
 (done) таск 2. подружить отправку и прием сообщений
 (done) (але це не точно) таск 7. баг с обнаружением устройства.
 (done) таск 10. баг последнего сообщения (скорее всего залазит за область екрана)

 v0.12.3
(done) не обновляются обнаруженные друзья: только после перехода по навигации
(done) таск 1. проверить что будет происходить у "Друзей" после дисконекта и коннекта
(done) таск 4. разбирать друзей на активных и не активных (первым списком выводить друзей онлайн, вторым, всех в куче)
            добавить отображение друзей онлайн (пропадают только по onDestroy), не отображаются когда оффлайн

 v0.12.4
 (done) таск 6.  раскидывать на все устройства изменения в профиле
 (done) таск 15. зміни в профілі іншого користувача не підтягуються відразу при коннекті
 (done) таск 13. Реалізувати видалення друзів (для початку, тільки коли два користувачі онлайн)
 (done) таск 19. при получении запроса вкладка incoming requests остается серой

 v0.12.5
 (done) таск 3. чистить список addFriends после добавления друга ( не добавлять друзей в список поиска друзей)
 (done) таск 5. список "add friends" не чистится после добавления нового друга
 (done) таск 8. removeActiveUser clientPartP2p теряется ссылка на клиент, и скорее всего по этой причине критическая ошибка
 (done) таск 17. підтягувати userInfo для перегляду інших користувачів
 (done) таск 20. після додавання користувача в друзі вкладка addFriends не чиститься
 (done) таск 21. щойно додані користувачі світяться як "оффлайн"
 (done) таск 22. після видалення друга - відображати його у вкладці addFriends
 (done) таск 23. delete for all (friends) з іншого пристрою користувач переходить в оффлайн замість видалення
 (done) таск 25. Баг корректного відображення відхиленого запиту в друзі

v0.12.6
 (done) таск 12. баг непоследовательности сообщений в сопряжении (добавляется не на последнее место в чате)
            (если удалять крайние сообщения - выглядит так, буд-то счётчик откатывается на пару сообщений назад
 таск 9. подружить синхронное удаление сообщений (кнопка "видалити у себе", що буде працювати завжди, "кнопка" видалити у всіх, що буде доступна при активному з'єднанні)
 (done) таск 24. перенести friends Online, friends offline в clientPartP2p
 (something went wrong...) таск 30. написать контроллер входящих сообщений (handler)
 (done) таск 27. маркировать собеседника как онлайн\оффлайн

v0.12.7
 (done) таск 29. сделать "шапку чата", где будет выводится пользователь, если чат приватный
             (для початку: виводити назву чату. якщо чат приватний - виводити статус Онлайна користувача)
 (done) таск 31. в useCase вынести send-delete message
 (done) таск 32. фикс отправки сообщений
 (done) таск 33. фикс удаления сообщеений
 (done) таск 35, в чате выводится не имя пользователя, а его уникальный id

v0.12.8 --> to v0.15.0
 (done) таск 26. делать кнопку отправки сообщения серой, когда собеседник оффлайн, и отправлять всплывающий тост
 (done) таск 34. фикс всплывающего уведомления, что пользователь оффлайн
            (почему оно вообще всплывает со старта, если должно всплывать по onClick. а на деле - наоборот)
 (done) таск 36. сделать скрол сообщений к последнему добавленому
 (done) таск 37. шапка чата - подтягивать пользователя не из друзей онлайн, а из базы данных
 (done) таск 39. сделать сортировку чат айтемов по последнему сообщению
 (done) таск 38. екран чатов. чат с собой называть как "заметки" (не указывать статус онлайн-оффлайн. (скорее всего вывести как отдельный елемент вне списка
           к остальным чатам прикрутить статус онлайн-оффлайн
 (done) таск 28. добавить логику чата для заметок пользователя (чат для 1го)

v0.15.0
 (done... may be) таск 41. при появлении пользователя онлайн - будучи на вкладках чата и списка чатов пользователь остается оффлайн
 (done) таск 42. відсутність дефолт лого друга та фактичного лого (проблема сприйняття пустого бітмапу різними телефонами.
                (фактичне лого відсутнє в силу необхідності використання інших потоків для пересилання медіа)
 (done) таск 51. зробити концепцію збереження логотипу та баннеру користувача. зберігаємо у сховище застосунку
 (done) таск 49. інтенд-ідентифікатор для медіа. SEND_LOGO, SEND_BANNER, SEND_MEDIA (далі SEND_POST)
 (done) таск 50. опис: зроблено медіа_сервер нетті
 (done) таск 47. медіа хендлер. Отримувати данні з джейсону, створювати необхідні папки за типами файлів,
            дозволи до сховища данних

v0.15.1
 (done) таск 58. створити клієнт або додати функціонал в існуючий клієнт для роботи з MediaServer
 (making-media-concept)таск 18. при передачі картинки користувача виникає переповнення буферу. надсилати картинку окремим медіа-потоком
 (done) таск 45. Зробити концепцію прийому медіа окремими каналами.
                     клієнт кидає запит SendMediaMessage -> Сервер запускає окремий медіа-сервер. відсилає клієнту "ок" та вказує порт медіа-серверу (подумати над цим. це може бути зайве)
                     (також має бути сформований стек файлів, що мають відправитись)
                     файли будуть надсилатись почергово зі стеку (хоча..
             // p.s. в чорновому варіанті файли будуть надсилатись потоково

 (prior) таск 60. в нетти сервер написать обработчик MessageType.REQUEST_MEDIA_SERVER,
        который будет через client p2p отправлять запросившему клиенту запрос на передачу TransferMediaIntend.MEDIA_EXTERNAL с
        с указанием чего именно. после этого тот сервер открывает медиаклиент и отправляет данные медиасерверу


 таск 55. Передача медіа userInfo   (class ChangesNotifierUseCase)

 таск 14. відправка баннеру користувача окремим send media request. при цьому server handler має назначати URI в userInfo при збереженні зображення
            (також розбити на два окремі оновлення: about та banner

 таск 40. при изменении UserInfo  (about)  крашнулся принимающий клиент





 таск 11. отправка медиа через чат, возможность просмотра фото-видео в чате

 таск 16. додати можливість скидати фото ( видаляти)

 таск 25. в  Message сделать поле "reply" default null, при нажатии туда - подкреплять сообщение к полю ввода
            ( с крестиком для возможности закрытия)

 таск 43. Баг одновременного включения устройств (дальше пиры не обнаруживают друг друга)

 таск 44. Создать папку для хранения медиа сообщений.
        При приеме нового медиа, проверять его тип, если в папке не создана папка с указаным типом - создавать новую папку
        Сохранили медиа, указали в message content URI медиа.

 таск 46. логика медиа диспетчера - завязать как синглтон на 2 сервера, как общий стейт. Блокирует очередь - медиадиспетчер,

 таск 48. чи треба відкривати mediaHandler (media server) в скопі корутин.
          Також щодо MediaChunk та як він реалізовує запис у файл.

 таск 52. media handler зробити обробник помилок для chat inactive

 таск 53. TransferMediaIntend.MEDIA_USER_LOGO -> отримувати лого з URI / чи з файлу,додавати в бд та видаляти лого з памяті пристрою
            підв'язати storageRepository та виконувати це через нього

 таск 54. Контроль буферу на передачу данних для серверу та клієнту. транспортна логіка

 таск 57. FriendsScreen, ChatsScreen фікс іконок

 таск 59. отчёт сервера клиенту за каждый принятый пакет


...next 60.





 Концепція 1. порівняння ХЕШІВ перед відправкою об'єктів. Ввести порівняння ХЕШу у пірів з об'єктом
        що планується скидати, якщо вони перед надсиланням ідентичні - надсилати лише зміну для об'єкту
        (або потім просто роздробити на окремі запити)
 Концепція 2. "pending". Подумати над реалізацією "очікуючих" CRUD-операцій та часу їх існування

 Концепція 3. Налаштувати pipeline

 Концепція 4. шифровані зображення. 1. не зберігати їх в пам'яті пристрою, зберігати у вигляді кешу застосунку

 Концепція 5. клієнт для медіа. Розбивати медіа на шматки вказаної довжини. якщо сервер втратить певний шматок, то звернеться до клієнта, щоб він переслав його заново
            val chunks = mutableListOf<String>()

 Концепція 6. обмеження медіа-трафіку. подумати над цим/*** обмеження трафіку pipeline.addLast(GlobalTrafficShapingHandler(workerGroup, 10_000_000, 10_000_000))  */10 МБ/с на канал
------------------------------------------------------------------------------------------------------------

Будущие идеи:
    - При первом подключении сканировать QR-код друг друга, и этим способом делать handshake, например как passphrase
                    val networkSpecifier = WifiAwareNetworkSpecifier.Builder(session, peerHandle)
                            .setPskPassphrase("netty_secure")
                            .build()


------------------------------------------------------------------------------------------------------------
Архитектура сервиса

1.Разделение понятий группы и соединения

<Владелец> создает группу, принимает соединения.

<Пользователь 1> подключается к групе. устанавливает соединение. отправляет whoami
<Владелец> добавляет <пользователя 1>. в ответ отправляет ему whoami.
дальше отправляет ему список активных подключений, на каждое новое подключение производит рассылку новых подключений остальным пользователям
выполнение рассылки подключений будет выполнятся на серверной стороне


Соответственно создадим сущность, которую будем передавать.  Greeting
Инициация в клиенте. ответ "Greeting" на запрос whoami:  Greeting(queueId, peerList)// пиры выделяют его как groupLeader
Cетевые запросы(к серверу): queue: EXCLUDE, INCLUDE


Клиенты должны для себя выделять <Владельца> группы. для возможности отправлять ему запросы, по типу
     QUEUE_IGNORE(запрос для не включения в очередь на следующего <Владельца> группы)
     QUEUE_ADD(запрос обратный QUEUE_IGNORE)

------------------------------------------------------------------------------------------------------------
создаем сервис. запускаем клиент, если через 10 секунд клиент не нашел группу, то организовуем группу сами.

Инициализация соединения: запрос whoami: после отправки запроса и закрытия канала мы устанавливаем соединение. соответственно мы и изымаем этого пользователя со списка активных. подумать над этим

включение сервиса включает nsd и нетти сервер.
отдельное включение как сервера

_____________________________
В чатах сообщения в хронологическом порядке.
Все действия на учасников чата выносятся во временную зону до усогласования со всеми учасниками чата (например удаление после всех "галочек"

_____________________________