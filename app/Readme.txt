///
notes
./gradlew wrapper --gradle-version=8.7 - если возникает ошибка версии gradle на другом компьютере


//

TODO
UserInfo
    - привязать инфо к уникальному id (устройства)
    - реализовать прием UserInfo
    // альтернатива: отправлять вместе с данными о пользователе

NettyServer
    - сделать обработку ошибок закрытия соединения с клиентом
    - сделать логику работы security handler
                handshake и тд

NettyServerHandler
    - добавить логику подтверждения добавления пользователя (approve\drop)


SEND_MESSAGE
    - корректно сформировать json, с указанием его типа и сопутствующих полей

TODO: ClientPartP2P - установить обработчик, который будет рассылать пирам данные о пользователе, если они изменились


TODO: FEATURE
    В PeerDiscovery оставлен баг для отладки
    //if(SERIVCE_NAME != event.name) {
    }
TODO: баг сравнения user в серверной части (discovery или server). ибо изначально переопределялся equals и hashcode (возможно этой ошибки и не допустил)

идея discovery - добавить возможность обновлять найденые сервисы, и кнопки включения-отключения discovery

идея для хранения клиентских подключений:
    Map<SocketAddress, Channel>:
        нашли пира, на onClick к нему создаем клиентский канал. Добавляем в мап значение канала и ключ User \
        далее для отправки сообщения к нему будет использоватся метод: sendTo(user: User, message: String) //p.s. message: String - рассмотрим возможность отправки другого типа данных. возможно ByteArray

 п2п клиент. клас, который должен хранить все подключения, обращаться месседжами к подключению через переданого ему юзера, и следить за добавлением, изъятием пользователей


 .................................
 прописать функциональность сервера
 /***
    Сервер: * підіймає discovery, виявляє інші сервіси     (можливо скоротити до пошуку безпосередньо наших активних сервісів netty)
            * підіймає сервер, що приймає вхідні данні
            * контролює втрату зв'язку з клієнтами та відображає це клієнтській частині п2п
            * відправляє клієнтський запит з вказанням данних користувача "серверу"
            * створює "нотифікації"
 */
 ..................................
 прописать функциональность клиента
 /***
    Клієнт: * зберігає активних користувачів-друзів         MutableStateFlow<MutableMap<User, NettyClient>>(mutableMapOf())
            * зберігая активних користувачів-сторонніх      MutableStateFlow<MutableSet<User>>(mutableSetOf())
            * надає методи серверній частині для підняття\вимкнення клієнтської сторони
            * надає viewModel метод send для відправки повідомлень
 */





 v0.05
(DONE) Goals:
(DONE)    - проверить работоспособность подключения через wifi-direct на физических устройствах.
(DONE)    - сделать интерфейс сообщений
(DONE)    - friendsScreen tab3 - сделать "waiting for consent to connect" (отдельный список. когда он пуст - сделать вкладку - disable)
(DONE)    - UPD: Третюю вкладку оставить для апрувов, а отображение запрошеных оставить в листе пиров: (добавить кнопки "cancel" + disabled "approve")
(DONE)    - friends screen - реализовать отправку запроса в друзья пользователям
(DONE)    - сделать статусы запросов: request: request-approve, request-cancel, request-reject, request-delete.
(DONE)    - проверить логику добавления и удаления пользователей из базы данных
(DONE)    - перебрать логику реквест-респонса
(DONE)    - создать в client part 2 списка: approving users and requested users
(DONE)    - подумать что сделать с полем id класа User. нас не устраивает, в каждой базе данных своя уникальная номерация, которая передается в нашу базу данных
(DONE)    - баг User: реализовать взаимосвязть User по уникальному id, но если переделать hashcode и еquals - будут проблемы обновления ui
                        (был создан UserDTO, который вместо user взаимодействует с ui)
(DONE)    - Friend item: реализовать навигацию в сообщения
(DONE)    - сделать интерфейс списка чатов
(DONE)    - пересмотреть навигацию по приложению
(REJECTED)- переделать реализацию базы данных: chat participent с id владельца базы данных, chatId и participent
                (была переделана реализация БД)
(DONE)    - сделать логику добавления и удаления пользователя и чата одновременно
            (решено посредством установки имени чата равное уникальному id пользователя, с которым ведётся чат)
(DONE)    - сделать чат айтем - "заметки", реализовать возможность написания туда сообщений
                (частично реализовано путём преобразования личного чата)
(DONE)    - send message model: пользователь отправляет сообщение, ждёт подтверждения приема сообщения с его датой получения, и id в базе данных
                        описание:
(REJECTED)                         *краткий кейс: пользователь отправил сообщение, и ждёт колбек для добавления сообщения в бд.
(NEXT)                              * если сообщение не будет доставлено  - будет ошибка. тут в силу вступают статусы сообщения.
(DONE)                              Альтернатива: сделать ID сообщения типом строка, и подписывать как пользователь + числовое значение id
(DONE)    - реализовать CRUD-операции для сообщений + возможность копировать текст
(DONE)    - //toast включите wifi + геолокацию wifi direct manager

(DONE) feachure: ошибка перезаписи нашего пользователя, если мы обнаруживаем пользователя с id= 1 // сейчас обращения ведутся по униклаьным айди пользователя, вместо порядковых в бд
            удаление сообщений будет производится лишь на своем устройстве. Пока как-то так //Решается путём выполнения операций, когда статус собеседника - онлайн


------------------------------------------------------------------------------------------------------------

 v0.06
 Goals:
          - реализовать "ожидающие сообщения" (для будущих  версий)
          - реализовать отображение "неудачно отправленых сообщений", с кнопкой "переслать обратно" (для будущих  версий)
          - забегаю на перед: статус проверки: сообщение можно будет успешно принять, только если id отправителя совпадает с айди чат-мембера в чате

          - для личных чатов сделать кнопку "удалить везде", которая будет enabled, когда собеседник онлайн
          - до CRUD-операций с сообщениями добавить кнопку "изменить, которая будет активна когда собеседник онлайн"
          - message item: реализовать кнопки: reply, redirect
(DONE)    - баг сообщений. сообщения то добавляются, то перезаписываются
          - реализовать возможность добавления медиа в чат (передачу картинок, видео, и тд. архивы и прочее файлы, скорее всего, отдельно)

(DONE)    - реализовать логику добавления\измеения иконки пользователя (с служебным класом для ее CRUD-операций)
(DONE)    - реализовать логику добавления\измеения баннера пользователя
                        (загвоздка в способе хранения изображения: оптимальнее для нас (но не для базы данных ) хранить в бд, ограничивая объем файла
                         правильнее - хранить в кеше приложения и в userInfo передавать uri. Как вариант - сделать userInfoDTО, который будет передавать файл картинки
                         Подзадачи:
          - пользователю будет отправлятся userInfoDTO, на базе userInfo.
(READ)                      - userInfo станет внутренним для нашего приложения, для хранения дичных данных.
                  (DONE)    - обращаемся в хранилище. запихиваем картинку в хранилище. оставляем ссылку в базе данных userInfo.banner
                            - когда значение меняется - преобразовуем userInfo в userInfoDTO и отправляем пользователю.
(DONE)    - добавить отображение онлайн-статуса пользователя
                Подзадачи:
          (DONE)    - когда сервис работает - статус онлайн. переменная или stateFlow в сервисе, или бродкаст
          (DONE)    - кнопку в меню для включения-отключения сервиса
          (REJECTED)- разделить логику discovery и работу кластеров
(DONE?)   - исправить баг запуска сервиса с ошибкой создания группы  p.s. (отпала путём оборачивания createGroup в корутину)


 todo         - сделать DTO для пересылаемых типов данных
          - сделать дефолтную иконку

 Main:
          - peerListListener в wifi direct manager. отследить работоспособность
          - проверить присвоение id для обнаруженых устройств. Не присваивать id автоматически. присваивать в порядке добавления, когда мы его уже добавляем в друзья

 Main 0.06:
(DONE)    - Сервер:
                (DONE) - Создаем группу                (Клас DirectGroupManager)
                (DONE) - Поднимаем локальный сервис
                                (Включением-выключением локального сервиса Можем управлять видимостью для посторонних устройств)
                (DONE) - Публикуем NSD (непосредственно для подключения через сеть. так же можно будет использовать через wifi в рамках одной локальной сети)
                (DONE) - создаем клас, который будет отвечать за эти действия (WiFiDirectService)
                (DONE) - ошибка удаления подключеного пользователя, при разрыве подключения
                                (выявлена при тестировании на том же устройстве.
                                может сопуствтоватся ошибкой добавления пользователя)
                (DONE) - отследить где удаляется активный пользователь.
                (DONE)          (после запроса whoami, сервер разрывает соединение и подключается как клиент)
                (DONE)              соответственно, после разрыва клиентского соединения, нужно изымать активного пользователя
                (DONE)             - вынести логику добавления -удаления активного пользвателя в клиентскую часть addActiveUser
                (DONE)  - убрать проверку на ту же машину, и проверять какой пользователь подключился. если наш - то отключатся от сервиса

Feature:


(после тестирования работоспособности р2р)    - chat dialog viewModel реализовать логику проверки онлайн-статуса учасников чата (актуально для груповых чатов)


------------------------------------------------------------------------------------------------------------
 v0.10
 Реализовано подключение и обнаружение в рамках сети

 todo:

(DONE)    - фикс добавления в друзья
(CANCELED)    - прописать отправку user info
    - добавить отправку реквеста на получение user info, если данные отсутствуют
(CHECK IT)    - фикс проблем с обновлением интерфейса
    - добавить систему уведомлений (на будущее)
    - фикс обнаружения + подключения через wifi direct
    - переписать уровень репозитория с LiveData на Flow


------------------------------------------------------------------------------------------------------------
 v0.12
 (done) таск 2. подружить отправку и прием сообщений
 (done) (але це не точно) таск 7. баг с обнаружением устройства.
 (done) таск 10. баг последнего сообщения (скорее всего залазит за область екрана)

 не обновляются обнаруженные друзья: только после перехода по навигации

 таск 1. проверить что будет происходить у "Друзей" после дисконекта и коннекта
            добавить отображение друзей онлайн (пропадают только по onDestroy), не отображаются когда оффлайн

 (on test) таск 3. чистить список addFriends после добавления друга ( не добавлять друзей в список поиска друзей)

 таск 4. разбирать друзей на активных и не активных (первым списком выводить друзей онлайн, вторым, всех в куче)

 таск 5. список "add friends" не чистится после добавления нового друга

 таск 6. раскидывать на все устройства изменения в профиле

 таск 8. removeActiveUser clientPartP2p теряется ссылка на клиент, и скорее всего по этой причине критическая ошибка

 таск 9. подружить синхронное удаление сообщений

 таск 11. отправка медиа через чат, возможность просмотра фото-видео в чате

 таск 12. баг непоследовательности сообщений в сопряжении (добавляется не на последнее место в чате)
------------------------------------------------------------------------------------------------------------

Будущие идеи:
    - При первом подключении сканировать QR-код друг друга, и этим способом делать handshake, например как passphrase
                    val networkSpecifier = WifiAwareNetworkSpecifier.Builder(session, peerHandle)
                            .setPskPassphrase("netty_secure")
                            .build()


------------------------------------------------------------------------------------------------------------
Архитектура сервиса

1.Разделение понятий группы и соединения

<Владелец> создает группу, принимает соединения.

<Пользователь 1> подключается к групе. устанавливает соединение. отправляет whoami
<Владелец> добавляет <пользователя 1>. в ответ отправляет ему whoami.
дальше отправляет ему список активных подключений, на каждое новое подключение производит рассылку новых подключений остальным пользователям
выполнение рассылки подключений будет выполнятся на серверной стороне


Соответственно создадим сущность, которую будем передавать.  Greeting
Инициация в клиенте. ответ "Greeting" на запрос whoami:  Greeting(queueId, peerList)// пиры выделяют его как groupLeader
Cетевые запросы(к серверу): queue: EXCLUDE, INCLUDE


Клиенты должны для себя выделять <Владельца> группы. для возможности отправлять ему запросы, по типу
     QUEUE_IGNORE(запрос для не включения в очередь на следующего <Владельца> группы)
     QUEUE_ADD(запрос обратный QUEUE_IGNORE)

------------------------------------------------------------------------------------------------------------
создаем сервис. запускаем клиент, если через 10 секунд клиент не нашел группу, то организовуем группу сами.

Инициализация соединения: запрос whoami: после отправки запроса и закрытия канала мы устанавливаем соединение. соответственно мы и изымаем этого пользователя со списка активных. подумать над этим

включение сервиса включает nsd и нетти сервер.
отдельное включение как сервера

_____________________________
В чатах сообщения в хронологическом порядке.
Все действия на учасников чата выносятся во временную зону до усогласования со всеми учасниками чата (например удаление после всех "галочек"

_____________________________