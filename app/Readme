Goals:
    - подружить адрессацию с wifi, а не с 127.0.0.1
    - логику whoami отправить в channelActive клиента (сейчас не актуально ибо фактического соединения мы не устанавливаем). возможно и потом не актуально, ибо мы ж сразу
        должны отправить данные при обнаружении

TODO
UserInfo
    - привязать инфо к уникальному id (устройства)
    - реализовать прием UserInfo
    // альтернатива: отправлять вместе с данными о пользователе

NettyServer
    - сделать обработку ошибок закрытия соединения с клиентом
    - сделать логику работы security handler
                handshake и тд

NettyServerHandler
    - добавить логику подтверждения добавления пользователя (approve\drop)


SEND_MESSAGE
    - корректно сформировать json, с указанием его типа и сопутствующих полей

TODO: ClientPartP2P - установить обработчик, который будет рассылать пирам данные о пользователе, если они изменились


TODO: FEATURE
    В PeerDiscovery оставлен баг для отладки
    //if(SERIVCE_NAME != event.name) {
    }
TODO: баг сравнения user в серверной части (discovery или server). ибо изначально переопределялся equals и hashcode (возможно этой ошибки и не допустил)

идея discovery - добавить возможность обновлять найденые сервисы, и кнопки включения-отключения discovery

идея для хранения клиентских подключений:
    Map<SocketAddress, Channel>:
        нашли пира, на onClick к нему создаем клиентский канал. Добавляем в мап значение канала и ключ User \
        далее для отправки сообщения к нему будет использоватся метод: sendTo(user: User, message: String) //p.s. message: String - рассмотрим возможность отправки другого типа данных. возможно ByteArray

 п2п клиент. клас, который должен хранить все подключения, обращаться месседжами к подключению через переданого ему юзера, и следить за добавлением, изъятием пользователей

 TODO: FIX
        слабая точка: логика взаимодействия request-response.


 .................................
 прописать функциональность сервера
 /***
    Сервер: * підіймає discovery, виявляє інші сервіси     (можливо скоротити до пошуку безпосередньо наших активних сервісів netty)
            * підіймає сервер, що приймає вхідні данні
            * контролює втрату зв'язку з клієнтами та відображає це клієнтській частині п2п
            * відправляє клієнтський запит з вказанням данних користувача "серверу"
            * створює "нотифікації"
 */
 ..................................
 прописать функциональность клиента
 /***
    Клієнт: * зберігає активних користувачів-друзів         MutableStateFlow<MutableMap<User, NettyClient>>(mutableMapOf())
            * зберігая активних користувачів-сторонніх      MutableStateFlow<MutableSet<User>>(mutableSetOf())
            * надає методи серверній частині для підняття\вимкнення клієнтської сторони
            * надає viewModel метод send для відправки повідомлень
 */





 v0.05
 Goals:
(DONE)    - проверить работоспособность подключения через wifi-direct на физических устройствах.
(DONE)    - сделать интерфейс сообщений
(DONE)    - friendsScreen tab3 - сделать "waiting for consent to connect" (отдельный список. когда он пуст - сделать вкладку - disable)
(DONE)    - UPD: Третюю вкладку оставить для апрувов, а отображение запрошеных оставить в листе пиров: (добавить кнопки "cancel" + disabled "approve")
(DONE)    - friends screen - реализовать отправку запроса в друзья пользователям
(DONE)    - сделать статусы запросов: request: request-approve, request-cancel, request-reject, request-delete.
(DONE)    - проверить логику добавления и удаления пользователей из базы данных
(DONE)    - перебрать логику реквест-респонса
(DONE)    - создать в client part 2 списка: approving users and requested users
(DONE)    - подумать что сделать с полем id класа User. нас не устраивает, в каждой базе данных своя уникальная номерация, которая передается в нашу базу данных
(DONE)    - баг User: реализовать взаимосвязть User по уникальному id, но если переделать hashcode и еquals - будут проблемы обновления ui
                        (был создан UserDTO, который вместо user взаимодействует с ui)
(DONE)    - Friend item: реализовать навигацию в сообщения
(DONE)    - сделать интерфейс списка чатов
(DONE)    - пересмотреть навигацию по приложению
(REJECTED)- переделать реализацию базы данных: chat participent с id владельца базы данных, chatId и participent
                (была переделана реализация БД)
(DONE)    - сделать логику добавления и удаления пользователя и чата одновременно
            (решено посредством установки имени чата равное уникальному id пользователя, с которым ведётся чат)
(DONE)    - сделать чат айтем - "заметки", реализовать возможность написания туда сообщений
                (частично реализовано путём преобразования личного чата)
(DONE)    - send message model: пользователь отправляет сообщение, ждёт подтверждения приема сообщения с его датой получения, и id в базе данных
                        описание:
(REJECTED)                         *краткий кейс: пользователь отправил сообщение, и ждёт колбек для добавления сообщения в бд.
(NEXT)                              * если сообщение не будет доставлено  - будет ошибка. тут в силу вступают статусы сообщения.
(DONE)                              Альтернатива: сделать ID сообщения типом строка, и подписывать как пользователь + числовое значение id
(DONE)    - реализовать CRUD-операции для сообщений + возможность копировать текст
(DONE)    - //toast включите wifi + геолокацию wifi direct manager

(DONE) feachure: ошибка перезаписи нашего пользователя, если мы обнаруживаем пользователя с id= 1 // сейчас обращения ведутся по униклаьным айди пользователя, вместо порядковых в бд
            удаление сообщений будет производится лишь на своем устройстве. Пока как-то так //Решается путём выполнения операций, когда статус собеседника - онлайн


------------------------------------------------------------------------------------------------------------

 v0.06
 Goals:
          - реализовать "ожидающие сообщения" (для будущих  версий)
          - реализовать отображение "неудачно отправленых сообщений", с кнопкой "переслать обратно" (для будущих  версий)
          - забегаю на перед: статус проверки: сообщение можно будет успешно принять, только если id отправителя совпадает с айди чат-мембера в чате

          - для личных чатов сделать кнопку "удалить везде", которая будет enabled, когда собеседник онлайн
          - до CRUD-операций с сообщениями добавить кнопку "изменить, которая будет активна когда собеседник онлайн"
          - message item: реализовать кнопки: reply, redirect
(DONE)    - баг сообщений. сообщения то добавляются, то перезаписываются
          - реализовать возможность добавления медиа в чат (передачу картинок, видео, и тд. архивы и прочее файлы, скорее всего, отдельно)

(DONE)    - реализовать логику добавления\измеения иконки пользователя (с служебным класом для ее CRUD-операций)
          - реализовать логику добавления\измеения баннера пользователя
                        (загвоздка в способе хранения изображения: оптимальнее для нас (но не для базы данных ) хранить в бд, ограничивая объем файла
                         правильнее - хранить в кеше приложения и в userInfo передавать uri. Как вариант - сделать userInfoDTО, который будет передавать файл картинки
                         Подзадачи:
                            - пользователю будет отправлятся userInfoDTO, на базе userInfo.
                            - userInfo станет внутренним для нашего приложения, для хранения дичных данных.
                            - обращаемся в хранилище. запихиваем картинку в хранилище. оставляем ссылку в базе данных userInfo.banner
                            - когда значение меняется - преобразовуем userInfo в userDTO и отправляем пользователю.
          - добавить отображение онлайн-статуса пользователя


 todo         - сделать DTO для пересылаемых типов данных
          - сделать дефолтную иконку

 Main:
          - peerListListener в wifi direct manager. отследить работоспособность
          - проверить присвоение id для обнаруженых устройств. Не присваивать id автоматически. присваивать в порядке добавления, когда мы его уже добавляем в друзья


(после тестирования работоспособности р2р)    - chat dialog viewModel реализовать логику проверки онлайн-статуса учасников чата (актуально для груповых чатов)


------------------------------------------------------------------------------------------------------------

Будущие идеи:
    - При первом подключении сканировать QR-код друг друга, и этим способом делать handshake, например как passphrase
                    val networkSpecifier = WifiAwareNetworkSpecifier.Builder(session, peerHandle)
                            .setPskPassphrase("netty_secure")
                            .build()